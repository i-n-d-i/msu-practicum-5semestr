## second homework - обходы графов

#### 1-Обход в глубину
Дан неориентированный невзвешенный граф. Для него вам необходимо найти количество вершин, лежащих в одной компоненте связности с данной вершиной (считая эту вершину). Используйте алгоритм обхода в глубину. Опишите класс TGraph с методами для чтения из потока ввода ReadFromStream(std::istream& stream), нахождения компоненты связности GetConnectedComponent(const uint32t vertex) const, а также другими вспомогательными приватными методами (например, DepthFirstSearch). При использовании отличного от Yandex C++ Style Guide стиля кодирования именование классов и методов может отличаться.

В первой строке входных данных содержатся два числа: N и S (1 ≤ N ≤ 100; 1 ≤ S ≤ N), где N – количество вершин графа, а S – заданная вершина. В следующих N строках записано по N чисел – матрица смежности графа, в которой 0 означает отсутствие ребра между вершинами, а 1 – его наличие. Гарантируется, что на главной диагонали матрицы всегда стоят нули.

Выведите одно целое число – искомое количество вершин. 

#### 2-Обход в ширину
Одна из Сверхсекретных организаций, чье название мы не имеем право разглашать, представляет собой сеть из N подземных бункеров, соединенных равными по длине туннелями, по которым из любого бункера можно добраться до любого другого (не обязательно напрямую). Связь с внешним миром осуществляется через специальные засекреченные выходы, которые расположены в некоторых из бункеров. Организации понадобилось составить план эвакуации персонала на случай экстренной ситуации. Для этого для каждого из бункеров необходимо узнать, сколько времени потребуется для того, чтобы добраться до ближайшего из выходов. Вам, как специалисту по таким задачам, поручено рассчитать необходимое время для каждого из бункеров по заданному описанию помещения Сверхсекретной организации. Для вашего же удобства бункеры занумерованы числами от 1 до N.

Как и в предыдущей задаче, используйте ООП. Реализуйте класс TGraph с методом BreadthFirstSearch(const std::vector<uint32_t>& startVertices) const, возвращающим вектор расстояний от заданного множества вершин до всех вершин графа. Класс графа должен иметь понятный интерфейс, т. е. уметь вычислять расстояния от любого заданного множества вершин до всех остальных, хранить в нём начальные вершины не стоит. Реализуйте отдельной функцией ReadExits(std::istream& stream) чтение выходов. Чтение графа может быть реализовано как методом класса ReadFromStream(std::istream& stream), так и в отдельной функции чтения и построения графа, возвращающей экземпляр класса TGraph.

Сначала вводятся два натуральных числа N, K (1 ≤ N ≤ 100000, 1 ≤ K ≤ N) — количество бункеров и количество выходов соответственно. Далее через пробел записаны K различных чисел от 1 до N, обозначающих номера бункеров, в которых расположены выходы. Потом идёт число M (1 ≤ M ≤ 100000) — количество туннелей. Далее вводятся M пар чисел – номера бункеров, соединенных туннелем. По каждому из туннелей можно двигаться в обе стороны. В организации не существует туннелей, ведущих из бункера в самого себя, зато может существовать более одного туннеля между парой бункеров.

Выведите N чисел, разделенных пробелом — для каждого из бункеров минимальное время, необходимое чтобы добраться до выхода. Считайте, что время перемещения по одному туннелю равно 1.

#### 3-Наличие цикла
Дан ориентированный граф. Используя алгоритм обхода в глубину, требуется определить, есть ли в нем цикл. Реализуйте класс TGraph с приватным методом DepthFirstSearch и публичным методом bool HasCycle() const.

В первой строке вводится число вершин N ≤ 50. Далее в N строках следуют по N чисел, каждое из которых – 0 или 1. j-ое число в i-ой строке равно 1 тогда и только тогда, когда существует ребро, идущее из i-ой вершины в j-ую. Гарантируется, что на диагонали матрицы будут стоять нули.

Выведите 0, если в заданном графе цикла нет, и 1, если он есть. 

#### 4-Топологическая сортировка
Группа солдат-новобранцев прибыла в армейскую часть N666. После знакомства с прапорщиком стало очевидно, что от работ на кухне по очистке картофеля спасти солдат может только чудо. Прапорщик, будучи не в состоянии запомнить фамилии, пронумеровал новобранцев от 1 до N. После этого он велел им построиться по росту (начиная с самого высокого). С этой несложной задачей могут справиться даже совсем необученные новобранцы, да вот беда, прапорщик уверил себя, что знает про некоторых солдат, кто из них кого выше, и это далеко не всегда соответствует истине. После трех дней обучения новобранцам удалось выяснить, что знает (а точнее, думает, что знает) прапорщик. Помогите им, используя эти знания, построиться так, чтобы товарищ прапорщик остался доволен.

Реализуйте класс TGraph, интерфейс класса продумайте самостоятельно.

Сначала на вход программы поступают числа N и M (2 ≤ N ≤ 100, 1 ≤ M ≤ 5000) – количество солдат в роте и количество пар солдат, про которых прапорщик знает, кто из них выше. Далее идут эти пары чисел A и B по одной на строке (1 ≤ A,B ≤ N), что означает, что, по мнению прапорщика, солдат A выше, чем B. Не гарантируется, что все пары чисел во входных данных различны.

В первой строке выведите "Yes" (если можно построиться так, чтобы прапорщик остался доволен) или "No" (если нет). После ответа "Yes" на следующей строке выведите N чисел, разделенных пробелами, - одно из возможных построений. 

#### 5-Конденсация графа
Вам задан ориентированный граф с N вершинами и M ребрами (1 ≤ N ≤ 20000, 1 ≤ M ≤ 200000). Найдите компоненты сильной связности заданного графа и топологически отсортируйте его конденсацию. Реализуйте класс TGraph с необходимым публичным интерфейсом и приватными полями и методами.

Граф задан во входном файле следующим образом: первая строка содержит числа N и M. Каждая из следующих M строк содержит описание ребра — два целых числа из диапазона от 1 до N — номера начала и конца ребра.

На первой строке выведите число K — количество компонент сильной связности в заданном графе. На следующей строке выведите N чисел — для каждой вершины выведите номер компоненты сильной связности, которой принадлежит эта вершина. Компоненты сильной связности должны быть занумерованы таким образом, чтобы для любого ребра номер компоненты сильной связности его начала не превышал номера компоненты сильной связности его конца. 
